# 线程

[Python线程同步机制: Locks, RLocks, Semaphores, Conditions, Events和Queues](http://yoyzhou.github.io/blog/2013/02/28/python-threads-synchronization-locks/)

## 内核级线程 or 用户级线程
在计算机里面通常的分类是内核级线程和用户级线程。内核级线程的调度是由系统完成的，而用户级线程的调度是由用户来控制的。

### 内核级线程

### 用户级线程
那么Python标准库提供的线程是那一类呢？如果我们了解或者使用过gevent和eventlet，进行下对比，我们就很容易回答出来了。Python提供的线程是内核级的，而gevent和eventlet提供的则是用户级的线程。这类用户级的线程，我们叫它协程，也可以叫green thread。本文中的线程，主要针对Python标准库提供的线程。

## 什么叫线程安全
当多个线程同时运行时，保证运行结果符合预期，就是线程安全的。由于多线程执行时，存在线程的切换，而python线程的切换时机是不确定的。既有cooperative multitasking的调度，也有preemptive multitasking的调度。

```bash
python线程什么时候切换呢？
当一个线程开始sleep或者进行I/O操作时，另一个线程就有机会拿到GIL锁，开始执行它的代码。
这就是cooperative multitasking(协同多任务)。
同时，CPython也有preemptive multitasking(抢占式多任务处理)的机制：
在Python2，当一个线程无中断地运行了1000个字节码，
或者在Python3中，运行了15毫秒，那么它就会放弃GIL锁，另一个线程就可能开始运行。
```

既然线程的切换是不可控的，那么如何保证在线程切换时，不会影响逻辑？同时，在某些场景下，我们还要主动协调各线程的执行顺序，也就是要解决多个线程同步的问题。

## 如何实现线程安全

### 天生线程安全
所谓天生线程安全，就是线程代码中只对全局对象进行读操作，而不存在写操作。这种情况下，不论线程在何处中断，都不会影响各个线程本来的执行逻辑。这时，不需要做任何额外的事情。线程本身就是安全的。

### 实现原子操作
在一个线程中，有时，需要保证某一行或者某一段代码的逻辑是不可中断的，也就是说要保证这段代码执行的原子性，即，实现原子操作。如何实现原子操作呢？

其实，很简单，就是在执行代码的前后加互斥锁，放互斥锁就可以了。

标准库里面为我们提供的互斥锁有两种。一种是Lock，一种是RLock。RLock是可重入的版本。实现原子操作的代码如下
```python
mylock = threading.Lock()

with mylock:
      do_something()
```
由于python GIL的存在和最小执行单元是字节码，很多python built-in的类型的读写操作本身都是原子操作的。

但是有时候，python中的一行代码是被解释成了多条字节码，也就是非原子操作的。这时，是必须加锁的。

### 实现线程同步
线程同步是在锁的基础来实现的。通过锁来对各个线程的执行顺序进行控制。虽然在一定意义上，实现原子操作也是一种线程同步，但它更多是保证单个线程中的操作不被中断。

而我理解的线程同步，是一个线程需要等待其它线程完成特定任务之后，才能执行。多个线程之间有依赖关系。

### 总结
Python中的线程安全，就是通过加锁，来实现原子操作（不可中断），避免不确定的线程切换导致逻辑错误。